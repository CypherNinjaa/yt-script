<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Holographic Text | 60SecondDev</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Glitch animation for UI */
        .glitch {
            animation: glitch 1s linear infinite;
        }

        @keyframes glitch {

            2%,
            64% {
                transform: translate(2px, 0) skew(0deg);
            }

            4%,
            60% {
                transform: translate(-2px, 0) skew(0deg);
            }

            62% {
                transform: translate(0, 0) skew(5deg);
            }
        }
    </style>
</head>

<body>

    <div id="ui">
        <span class="glitch">Interactive Particle Engine // Move Mouse</span>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];

        // CONFIGURATION
        const TEXT = "LIKEâ¤ï¸";
        const FONT_SIZE = 180;
        const PARTICLE_DENSITY = 6; // Lower = more particles (Performance heavy)
        const MOUSE_RADIUS = 100;
        const FORCE_MULTIPLIER = 50;
        const RETURN_SPEED = 0.1; // 0.0 to 1.0
        const FRICTION = 0.9;

        let mouse = { x: null, y: null, radius: MOUSE_RADIUS };

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });

        // Handle window resize
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        }
        window.addEventListener('resize', resize);

        class Particle {
            constructor(x, y) {
                this.x = Math.random() * width; // Start random
                this.y = Math.random() * height;
                this.originX = x; // Target position (Home)
                this.originY = y;
                this.vx = 0; // Velocity
                this.vy = 0;
                this.size = 2;
                // Randomize color slightly for holographic look
                this.color = Math.random() > 0.5 ? '#00f3ff' : '#bc13fe';
            }

            update() {
                // Physics: Distance from mouse
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const forceDirectionX = dx / distance;
                const forceDirectionY = dy / distance;

                // Physics: Repulsion (Explosion)
                const maxDistance = mouse.radius;
                let force = 0;

                if (distance < maxDistance) {
                    force = (maxDistance - distance) / maxDistance;
                    const repulsionX = forceDirectionX * force * FORCE_MULTIPLIER;
                    const repulsionY = forceDirectionY * force * FORCE_MULTIPLIER;
                    this.vx -= repulsionX;
                    this.vy -= repulsionY;
                }

                // Physics: Return to Origin (Spring)
                if (this.x !== this.originX || this.y !== this.originY) {
                    const homeDx = this.originX - this.x;
                    const homeDy = this.originY - this.y;

                    // Simple spring force
                    this.vx += homeDx * RETURN_SPEED * 0.1;
                    this.vy += homeDy * RETURN_SPEED * 0.1;
                }

                // Apply Friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Move
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill();
            }
        }

        function init() {
            particles = [];
            ctx.clearRect(0, 0, width, height);

            // 1. Draw text effectively off-screen logic
            ctx.fillStyle = 'white';
            ctx.font = '900 ' + FONT_SIZE + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(TEXT, width / 2, height / 2);

            // 2. Scan pixel data
            // getImageData(x, y, w, h) returns an array of RGBA values
            const textCoordinates = ctx.getImageData(0, 0, width, height);

            // 3. Create particles where pixels exist
            // We skip pixels based on DENSITY to save performance
            for (let y = 0, y2 = textCoordinates.height; y < y2; y += PARTICLE_DENSITY) {
                for (let x = 0, x2 = textCoordinates.width; x < x2; x += PARTICLE_DENSITY) {
                    // Check alpha value (4th byte in RGBA)
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128) {
                        particles.push(new Particle(x, y));
                    }
                }
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Connect particles for "network" effect (Optional - heavy performance)
            // Keeping it off for pure fluid speed, but adding line logic here is possible.

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw();
            }
            requestAnimationFrame(animate);
        }

        // Initial start
        resize();
        animate();

    </script>
    <!-- 
     Based on the current social media landscape, there is a massive resurgence in **"Kinetic Typography"** and **"Interactive UI Elements"**. Viewers are tired of static websites; they crave interfaces that feel alive, playful, and responsive.

The trend is moving towards **"Micro-Interactions that scale"**â€”tiny details (like a hover effect) turned into the main event.

I have designed **"The Holographic Text Engine"**.
This code scans an HTML5 Canvas for pixel data, converts text into thousands of interactive particles, and applies "return-to-home" spring physics. Itâ€™s visually satisfying and extremely high-engagement because viewers immediately want to try it with their own names.

### **Video Strategy for Viral Impact**

1.  **The Hook (0:00):** Display the word "FUTURE" in giant, glowing letters.
    * *Script:* "Stop using static text. This is how you make fonts **explode** with JavaScript."
2.  **The Action (0:05):** Smash your mouse cursor into the text. Watch it shatter into thousands of particles and instantly reform.
    * *Script:* "I'm using the `getImageData` method to scan the text pixels and map them to a particle system."
3.  **The Flex (0:20):** Move the mouse smoothly to show the "liquid" effect.
    * *Script:* "We apply simple spring physics: if the mouse is close, flee. If the mouse is gone, return home."
4.  **The Outro (0:45):** Show the variable `const text = 'FUTURE'` and change it to your name.
    * *Script:* "Change one line of code to make it yours. Source is in the comments."

### **The Code**
Save this as `kinetic_text.html`.


http://googleusercontent.com/immersive_entry_chip/0

### **Metadata for Viral Reach**

**Title Options:**
1.  **Code that Explodes! ðŸ’¥ (Kinetic Typography Tutorial)**
2.  **Make Your Website Interactive in 60 Seconds ðŸ¤¯**
3.  **JavaScript Particle Text Effects (No Libraries)**

**Description:**
> Static text is boring. Let's make it explode. ðŸ’¥
>
> This is a **Kinetic Typography Engine** built with vanilla JavaScript. It works by scanning the pixels of a standard HTML5 Canvas text element and replacing them with thousands of physics-based particles.
>
> **How it works:**
> 1. Draw text to Canvas.
> 2. Use `ctx.getImageData()` to find where the pixels are.
> 3. Spawn particles at those coordinates.
> 4. Apply mouse repulsion physics.
>
> **#javascript #webdesign #frontend #coding #creativecoding**

**Tags:**
`javascript, kinetic typography, particle effects, html5 canvas, creative coding, web design, frontend developer, coding tutorial, interactive text, vanilla js, web development, 60seconddev` -->
</body>

</html>