<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Holographic Text | 60SecondDev</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.3);
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Glitch animation for UI */
        .glitch {
            animation: glitch 1s linear infinite;
        }

        @keyframes glitch {

            2%,
            64% {
                transform: translate(2px, 0) skew(0deg);
            }

            4%,
            60% {
                transform: translate(-2px, 0) skew(0deg);
            }

            62% {
                transform: translate(0, 0) skew(5deg);
            }
        }
    </style>
</head>

<body>

    <div id="ui">
        <span class="glitch">Interactive Particle Engine // Move Mouse</span>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];

        // CONFIGURATION
        const TEXT = "LIKE❤️";
        const FONT_SIZE = 180;
        const PARTICLE_DENSITY = 6; // Lower = more particles (Performance heavy)
        const MOUSE_RADIUS = 100;
        const FORCE_MULTIPLIER = 50;
        const RETURN_SPEED = 0.1; // 0.0 to 1.0
        const FRICTION = 0.9;

        let mouse = { x: null, y: null, radius: MOUSE_RADIUS };

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });

        // Handle window resize
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            init();
        }
        window.addEventListener('resize', resize);

        class Particle {
            constructor(x, y) {
                this.x = Math.random() * width; // Start random
                this.y = Math.random() * height;
                this.originX = x; // Target position (Home)
                this.originY = y;
                this.vx = 0; // Velocity
                this.vy = 0;
                this.size = 2;
                // Randomize color slightly for holographic look
                this.color = Math.random() > 0.5 ? '#00f3ff' : '#bc13fe';
            }

            update() {
                // Physics: Distance from mouse
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const forceDirectionX = dx / distance;
                const forceDirectionY = dy / distance;

                // Physics: Repulsion (Explosion)
                const maxDistance = mouse.radius;
                let force = 0;

                if (distance < maxDistance) {
                    force = (maxDistance - distance) / maxDistance;
                    const repulsionX = forceDirectionX * force * FORCE_MULTIPLIER;
                    const repulsionY = forceDirectionY * force * FORCE_MULTIPLIER;
                    this.vx -= repulsionX;
                    this.vy -= repulsionY;
                }

                // Physics: Return to Origin (Spring)
                if (this.x !== this.originX || this.y !== this.originY) {
                    const homeDx = this.originX - this.x;
                    const homeDy = this.originY - this.y;

                    // Simple spring force
                    this.vx += homeDx * RETURN_SPEED * 0.1;
                    this.vy += homeDy * RETURN_SPEED * 0.1;
                }

                // Apply Friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Move
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.size, this.size);
                ctx.fill();
            }
        }

        function init() {
            particles = [];
            ctx.clearRect(0, 0, width, height);

            // 1. Draw text effectively off-screen logic
            ctx.fillStyle = 'white';
            ctx.font = '900 ' + FONT_SIZE + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(TEXT, width / 2, height / 2);

            // 2. Scan pixel data
            // getImageData(x, y, w, h) returns an array of RGBA values
            const textCoordinates = ctx.getImageData(0, 0, width, height);

            // 3. Create particles where pixels exist
            // We skip pixels based on DENSITY to save performance
            for (let y = 0, y2 = textCoordinates.height; y < y2; y += PARTICLE_DENSITY) {
                for (let x = 0, x2 = textCoordinates.width; x < x2; x += PARTICLE_DENSITY) {
                    // Check alpha value (4th byte in RGBA)
                    if (textCoordinates.data[(y * 4 * textCoordinates.width) + (x * 4) + 3] > 128) {
                        particles.push(new Particle(x, y));
                    }
                }
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Connect particles for "network" effect (Optional - heavy performance)
            // Keeping it off for pure fluid speed, but adding line logic here is possible.

            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
                particles[i].draw();
            }
            requestAnimationFrame(animate);
        }

        // Initial start
        resize();
        animate();

    </script>
   
</body>

</html>